# P1.5-04: Visual Isolation

**Status**: Pending

**Goal**: Enable Claude to isolate or hide elements, create 3D section boxes, and change display styles to reduce visual noise and focus on relevant parts of the model.

**Prerequisites**: P1.5-03 complete.

---

## Files Created

```
src/RevitAI/Tools/ViewTools/
├── IsolateElementsTool.cs      # isolate_elements
├── HideElementsTool.cs         # hide_elements
├── ResetVisibilityTool.cs      # reset_visibility
├── Set3DSectionBoxTool.cs      # set_3d_section_box
├── ClearSectionBoxTool.cs      # clear_section_box
└── SetDisplayStyleTool.cs      # set_display_style
```

**Modified**: `src/RevitAI/App.cs` - Register all tools

---

## Tool Summary

| Tool Name | Input | Output | Transaction |
|-----------|-------|--------|-------------|
| `isolate_elements` | `element_ids: int[]`, `temporary?: bool` | Success | Depends |
| `hide_elements` | `element_ids: int[]`, `temporary?: bool` | Success | Depends |
| `reset_visibility` | `temporary_only?: bool` | Success | Depends |
| `set_3d_section_box` | `element_ids?: int[]` or bounds | Success | No* |
| `clear_section_box` | - | Success | No* |
| `set_display_style` | `style: string` | Success | No* |

*3D view section box and display style changes may require a transaction depending on the view state.

---

## Implementation Details

### Temporary vs Permanent Visibility

Revit offers two approaches for visibility control:

1. **Temporary Hide/Isolate** (`TemporaryViewMode`) - UI-level, not saved, easily reset
2. **Permanent Override** (`OverrideGraphicSettings`) - Saved with view, requires transaction

```csharp
// Temporary (default - recommended for AI operations)
view.EnableTemporaryViewPropertiesMode(view.Id);
view.IsolateElementsTemporary(elementIds);

// Permanent (requires transaction)
using (var trans = new Transaction(doc, "Isolate Elements"))
{
    trans.Start();
    foreach (var id in elementIds)
    {
        view.SetElementOverrides(id, overrideSettings);
    }
    trans.Commit();
}
```

### isolate_elements

Shows only the specified elements, hiding everything else.

```csharp
public class IsolateElementsTool : IRevitTool
{
    public string Name => "isolate_elements";

    public string Description =>
        "Isolates the specified elements, hiding all other elements in the view. " +
        "By default uses temporary isolation (not saved with view). " +
        "Set temporary=false for permanent isolation (saved with view).";

    public JsonElement InputSchema => JsonDocument.Parse("""
        {
            "type": "object",
            "properties": {
                "element_ids": {
                    "type": "array",
                    "items": { "type": "integer" },
                    "description": "Element IDs to isolate (show)"
                },
                "temporary": {
                    "type": "boolean",
                    "description": "Use temporary isolation (default true). False saves with view.",
                    "default": true
                }
            },
            "required": ["element_ids"]
        }
        """).RootElement;

    public bool RequiresTransaction => false; // Handled internally based on temporary flag

    public Task<ToolResult> ExecuteAsync(JsonElement input, UIApplication app, CancellationToken ct)
    {
        var uiDoc = app.ActiveUIDocument;
        var doc = uiDoc.Document;
        var view = uiDoc.ActiveView;

        var elementIds = input.GetProperty("element_ids").EnumerateArray()
            .Select(e => new ElementId(e.GetInt64()))
            .ToList();

        var temporary = !input.TryGetProperty("temporary", out var t) || t.GetBoolean();

        // Validate elements exist
        var validIds = elementIds.Where(id => doc.GetElement(id) != null).ToList();
        if (validIds.Count == 0)
            return Task.FromResult(ToolResult.Error("No valid elements found to isolate"));

        if (temporary)
        {
            view.IsolateElementsTemporary(validIds);
        }
        else
        {
            // Permanent isolation requires transaction
            using var trans = new Transaction(doc, "Isolate Elements");
            trans.Start();
            view.IsolateElements(validIds);
            trans.Commit();
        }

        return Task.FromResult(ToolResult.Success(new
        {
            action = "isolate",
            element_count = validIds.Count,
            temporary,
            view_name = view.Name
        }));
    }
}
```

### hide_elements

Hides the specified elements while keeping others visible.

```csharp
public class HideElementsTool : IRevitTool
{
    public string Name => "hide_elements";

    public string Description =>
        "Hides the specified elements in the current view. " +
        "Other elements remain visible. By default uses temporary hide.";

    public JsonElement InputSchema => JsonDocument.Parse("""
        {
            "type": "object",
            "properties": {
                "element_ids": {
                    "type": "array",
                    "items": { "type": "integer" },
                    "description": "Element IDs to hide"
                },
                "temporary": {
                    "type": "boolean",
                    "description": "Use temporary hide (default true). False saves with view.",
                    "default": true
                }
            },
            "required": ["element_ids"]
        }
        """).RootElement;

    public bool RequiresTransaction => false;

    public Task<ToolResult> ExecuteAsync(JsonElement input, UIApplication app, CancellationToken ct)
    {
        var uiDoc = app.ActiveUIDocument;
        var doc = uiDoc.Document;
        var view = uiDoc.ActiveView;

        var elementIds = input.GetProperty("element_ids").EnumerateArray()
            .Select(e => new ElementId(e.GetInt64()))
            .ToList();

        var temporary = !input.TryGetProperty("temporary", out var t) || t.GetBoolean();

        var validIds = elementIds.Where(id => doc.GetElement(id) != null).ToList();
        if (validIds.Count == 0)
            return Task.FromResult(ToolResult.Error("No valid elements found to hide"));

        if (temporary)
        {
            view.HideElementsTemporary(validIds);
        }
        else
        {
            using var trans = new Transaction(doc, "Hide Elements");
            trans.Start();
            view.HideElements(validIds);
            trans.Commit();
        }

        return Task.FromResult(ToolResult.Success(new
        {
            action = "hide",
            element_count = validIds.Count,
            temporary,
            view_name = view.Name
        }));
    }
}
```

### reset_visibility

Resets visibility overrides in the current view.

```csharp
public class ResetVisibilityTool : IRevitTool
{
    public string Name => "reset_visibility";

    public string Description =>
        "Resets visibility overrides in the current view. " +
        "By default resets temporary overrides only. Set temporary_only=false to also reset permanent overrides.";

    public JsonElement InputSchema => JsonDocument.Parse("""
        {
            "type": "object",
            "properties": {
                "temporary_only": {
                    "type": "boolean",
                    "description": "Only reset temporary overrides (default true)",
                    "default": true
                }
            }
        }
        """).RootElement;

    public bool RequiresTransaction => false;

    public Task<ToolResult> ExecuteAsync(JsonElement input, UIApplication app, CancellationToken ct)
    {
        var uiDoc = app.ActiveUIDocument;
        var doc = uiDoc.Document;
        var view = uiDoc.ActiveView;

        var temporaryOnly = !input.TryGetProperty("temporary_only", out var t) || t.GetBoolean();

        // Reset temporary overrides
        if (view.IsTemporaryViewPropertiesModeEnabled())
        {
            view.DisableTemporaryViewMode(TemporaryViewMode.TemporaryHideIsolate);
        }

        if (!temporaryOnly)
        {
            // Reset permanent overrides requires transaction
            using var trans = new Transaction(doc, "Reset Visibility");
            trans.Start();

            // Get all elements with overrides and clear them
            var collector = new FilteredElementCollector(doc, view.Id);
            foreach (var element in collector)
            {
                if (view.GetElementOverrides(element.Id).IsValidObject)
                {
                    view.SetElementOverrides(element.Id, new OverrideGraphicSettings());
                }
            }

            // Unhide any hidden elements
            var hiddenIds = collector
                .Where(e => e.IsHidden(view))
                .Select(e => e.Id)
                .ToList();

            if (hiddenIds.Any())
                view.UnhideElements(hiddenIds);

            trans.Commit();
        }

        return Task.FromResult(ToolResult.Success(new
        {
            action = "reset_visibility",
            temporary_only = temporaryOnly,
            view_name = view.Name
        }));
    }
}
```

### set_3d_section_box

Creates a section box in a 3D view to crop visible area.

```csharp
public class Set3DSectionBoxTool : IRevitTool
{
    public string Name => "set_3d_section_box";

    public string Description =>
        "Creates or updates the section box in a 3D view to focus on a specific area. " +
        "Specify element_ids to fit box around elements, or provide explicit bounds.";

    public JsonElement InputSchema => JsonDocument.Parse("""
        {
            "type": "object",
            "properties": {
                "element_ids": {
                    "type": "array",
                    "items": { "type": "integer" },
                    "description": "Element IDs to fit section box around (with padding)"
                },
                "min": {
                    "type": "object",
                    "description": "Minimum corner of section box (in feet)",
                    "properties": {
                        "x": { "type": "number" },
                        "y": { "type": "number" },
                        "z": { "type": "number" }
                    }
                },
                "max": {
                    "type": "object",
                    "description": "Maximum corner of section box (in feet)",
                    "properties": {
                        "x": { "type": "number" },
                        "y": { "type": "number" },
                        "z": { "type": "number" }
                    }
                },
                "padding": {
                    "type": "number",
                    "description": "Padding around elements in feet (default 5)",
                    "default": 5
                }
            }
        }
        """).RootElement;

    public bool RequiresTransaction => true;

    public Task<ToolResult> ExecuteAsync(JsonElement input, UIApplication app, CancellationToken ct)
    {
        var uiDoc = app.ActiveUIDocument;
        var doc = uiDoc.Document;
        var view = uiDoc.ActiveView as View3D;

        if (view == null)
            return Task.FromResult(ToolResult.Error("set_3d_section_box only works in 3D views"));

        var padding = input.TryGetProperty("padding", out var p) ? p.GetDouble() : 5.0;
        BoundingBoxXYZ sectionBox;

        if (input.TryGetProperty("element_ids", out var elemIdsProp))
        {
            var elementIds = elemIdsProp.EnumerateArray()
                .Select(e => new ElementId(e.GetInt64()))
                .ToList();

            // Calculate combined bounding box
            BoundingBoxXYZ combinedBox = null;
            foreach (var id in elementIds)
            {
                var element = doc.GetElement(id);
                if (element == null) continue;

                var box = element.get_BoundingBox(null); // null = model space
                if (box == null) continue;

                if (combinedBox == null)
                {
                    combinedBox = new BoundingBoxXYZ { Min = box.Min, Max = box.Max };
                }
                else
                {
                    combinedBox.Min = new XYZ(
                        Math.Min(combinedBox.Min.X, box.Min.X),
                        Math.Min(combinedBox.Min.Y, box.Min.Y),
                        Math.Min(combinedBox.Min.Z, box.Min.Z));
                    combinedBox.Max = new XYZ(
                        Math.Max(combinedBox.Max.X, box.Max.X),
                        Math.Max(combinedBox.Max.Y, box.Max.Y),
                        Math.Max(combinedBox.Max.Z, box.Max.Z));
                }
            }

            if (combinedBox == null)
                return Task.FromResult(ToolResult.Error("No valid element geometry found"));

            // Add padding
            sectionBox = new BoundingBoxXYZ
            {
                Min = combinedBox.Min - new XYZ(padding, padding, padding),
                Max = combinedBox.Max + new XYZ(padding, padding, padding)
            };
        }
        else if (input.TryGetProperty("min", out var minProp) && input.TryGetProperty("max", out var maxProp))
        {
            sectionBox = new BoundingBoxXYZ
            {
                Min = new XYZ(
                    minProp.GetProperty("x").GetDouble(),
                    minProp.GetProperty("y").GetDouble(),
                    minProp.GetProperty("z").GetDouble()),
                Max = new XYZ(
                    maxProp.GetProperty("x").GetDouble(),
                    maxProp.GetProperty("y").GetDouble(),
                    maxProp.GetProperty("z").GetDouble())
            };
        }
        else
        {
            return Task.FromResult(ToolResult.Error("Specify element_ids or min/max bounds"));
        }

        view.IsSectionBoxActive = true;
        view.SetSectionBox(sectionBox);

        return Task.FromResult(ToolResult.Success(new
        {
            action = "set_section_box",
            min = new { x = sectionBox.Min.X, y = sectionBox.Min.Y, z = sectionBox.Min.Z },
            max = new { x = sectionBox.Max.X, y = sectionBox.Max.Y, z = sectionBox.Max.Z },
            view_name = view.Name
        }));
    }
}
```

### clear_section_box

Removes the section box from a 3D view.

```csharp
public class ClearSectionBoxTool : IRevitTool
{
    public string Name => "clear_section_box";

    public string Description =>
        "Removes the section box from the current 3D view, showing the full model.";

    public JsonElement InputSchema => JsonDocument.Parse("""
        {
            "type": "object",
            "properties": {}
        }
        """).RootElement;

    public bool RequiresTransaction => true;

    public Task<ToolResult> ExecuteAsync(JsonElement input, UIApplication app, CancellationToken ct)
    {
        var view = app.ActiveUIDocument.ActiveView as View3D;

        if (view == null)
            return Task.FromResult(ToolResult.Error("clear_section_box only works in 3D views"));

        view.IsSectionBoxActive = false;

        return Task.FromResult(ToolResult.Success(new
        {
            action = "clear_section_box",
            view_name = view.Name
        }));
    }
}
```

### set_display_style

Changes the visual style of the current view.

```csharp
public class SetDisplayStyleTool : IRevitTool
{
    public string Name => "set_display_style";

    public string Description =>
        "Changes the display style (visual style) of the current view. " +
        "Options: Wireframe, HiddenLine, Shaded, ShadedWithEdges, Realistic, Consistent, Rendered.";

    public JsonElement InputSchema => JsonDocument.Parse("""
        {
            "type": "object",
            "properties": {
                "style": {
                    "type": "string",
                    "description": "Display style to apply",
                    "enum": ["Wireframe", "HiddenLine", "Shaded", "ShadedWithEdges",
                             "Realistic", "Consistent", "Rendered"]
                }
            },
            "required": ["style"]
        }
        """).RootElement;

    public bool RequiresTransaction => true;

    public Task<ToolResult> ExecuteAsync(JsonElement input, UIApplication app, CancellationToken ct)
    {
        var view = app.ActiveUIDocument.ActiveView;
        var styleStr = input.GetProperty("style").GetString();

        var displayStyle = styleStr switch
        {
            "Wireframe" => DisplayStyle.Wireframe,
            "HiddenLine" => DisplayStyle.HLR,
            "Shaded" => DisplayStyle.Shading,
            "ShadedWithEdges" => DisplayStyle.ShadingWithEdges,
            "Realistic" => DisplayStyle.Realistic,
            "Consistent" => DisplayStyle.FlatColors,
            "Rendered" => DisplayStyle.Rendering,
            _ => (DisplayStyle?)null
        };

        if (displayStyle == null)
            return Task.FromResult(ToolResult.Error($"Unknown display style: {styleStr}"));

        // Check if view supports this display style
        if (!view.CanUseDisplayStyle(displayStyle.Value))
            return Task.FromResult(ToolResult.Error(
                $"View '{view.Name}' does not support display style '{styleStr}'"));

        view.DisplayStyle = displayStyle.Value;

        return Task.FromResult(ToolResult.Success(new
        {
            action = "set_display_style",
            style = styleStr,
            view_name = view.Name
        }));
    }
}
```

---

## Usage Examples

### Claude isolating elements to reduce visual noise

```
User: Show me just the structural columns on Level 1

Claude: I'll isolate the structural columns on Level 1 for you.
[calls get_elements_by_category with category="structural columns", level="Level 1"]
Found 24 structural columns on Level 1.
[calls isolate_elements with those element IDs]
Done. I've isolated the 24 structural columns. All other elements are temporarily hidden.
Use reset_visibility when you want to see everything again.
```

### Claude using section box for focused analysis

```
User: I want to see just the area around grid intersection A-1

Claude: I'll create a section box around grid A-1 to focus on that area.
[calls get_grids to find grid coordinates]
[calculates intersection point]
[calls set_3d_section_box with bounds around intersection, padding 15 feet]
Done. I've created a section box centered on grid A-1 with 15 feet of clearance
on each side. You can now see the elements in that area without the rest of the
model obstructing the view.
```

---

## Verification Checklist

- [ ] `isolate_elements` shows only specified elements (temporary mode)
- [ ] `isolate_elements` with temporary=false saves isolation with view
- [ ] `hide_elements` hides specified elements while showing others
- [ ] `hide_elements` with temporary=false saves with view
- [ ] `reset_visibility` clears temporary overrides
- [ ] `reset_visibility` with temporary_only=false clears permanent overrides
- [ ] `set_3d_section_box` with element_ids creates appropriate box with padding
- [ ] `set_3d_section_box` with min/max creates exact box
- [ ] `clear_section_box` removes section box
- [ ] `set_display_style` applies all listed styles
- [ ] Error messages are helpful when operations fail

---

## Future Enhancements (Deferred)

| Enhancement | Target Phase | Notes |
|-------------|--------------|-------|
| Isolate by category | P2-04 | Isolate all elements of a category |
| Isolate by workset | P2-04 | For workshared models |
| Color overrides | P2-05 | Highlight elements with specific colors |
| Transparency overrides | P2-05 | Make elements semi-transparent |
| Filter-based visibility | P2-06 | Apply visibility based on parameter values |
