# P1.5-02: View Management

**Status**: Complete

**Goal**: Enable Claude to list available views, switch between views, open views from the Project Browser, and create new views of various types.

**Prerequisites**: P1.5-01 complete.

---

## Files Created

```
src/RevitAI/Tools/ViewTools/
├── GetViewListTool.cs              # get_view_list
├── SwitchViewTool.cs               # switch_view
├── OpenViewTool.cs                 # open_view
├── CreateFloorPlanViewTool.cs      # create_floor_plan_view
├── CreateCeilingPlanViewTool.cs    # create_ceiling_plan_view
├── Create3DViewTool.cs             # create_3d_view
├── CreateSectionViewTool.cs        # create_section_view
├── CreateElevationViewTool.cs      # create_elevation_view
├── CreateScheduleViewTool.cs       # create_schedule_view
├── CreateDraftingViewTool.cs       # create_drafting_view
├── DuplicateViewTool.cs            # duplicate_view
├── RenameViewTool.cs               # rename_view
└── DeleteViewTool.cs               # delete_view (requires confirmation)
```

**Enhanced**: `src/RevitAI/Tools/ReadTools/GetAvailableTypesTool.cs` - Added ViewFamilyType support

**Modified**: `src/RevitAI/App.cs` - Register all tools

---

## Tool Summary

| Tool Name | Input | Output | Transaction |
|-----------|-------|--------|-------------|
| `get_view_list` | `view_type?: string` | List of views with IDs | No |
| `switch_view` | `view_id: int` | Success + view info | No |
| `open_view` | `view_name: string`, `view_type?: string` | Opens view, returns info | No |
| `create_floor_plan_view` | `level_id: int`, `name: string`, `view_family_type_id?: int` | New view ID | Yes |
| `create_3d_view` | `name: string`, `orientation?: string` | New view ID | Yes |
| `create_section_view` | `name: string`, `origin: {x,y,z}`, `direction: {x,y,z}` | New view ID | Yes |
| `create_schedule_view` | `name: string`, `category: string`, `fields: string[]` | New view ID | Yes |
| `create_drafting_view` | `name: string`, `scale?: int` | New view ID | Yes |

---

## Implementation Details

### get_view_list

Lists all views in the project, optionally filtered by type.

```csharp
public class GetViewListTool : IRevitTool
{
    public string Name => "get_view_list";

    public string Description =>
        "Lists all views in the project. Use to find view IDs for switching, " +
        "or to understand what views are available. Filter by type: " +
        "FloorPlan, CeilingPlan, Elevation, Section, 3D, Schedule, Sheet, Drafting, Legend.";

    public JsonElement InputSchema => JsonDocument.Parse("""
        {
            "type": "object",
            "properties": {
                "view_type": {
                    "type": "string",
                    "description": "Filter by view type (FloorPlan, CeilingPlan, Elevation, Section, 3D, Schedule, Sheet, Drafting, Legend)",
                    "enum": ["FloorPlan", "CeilingPlan", "Elevation", "Section", "3D", "Schedule", "Sheet", "Drafting", "Legend"]
                }
            }
        }
        """).RootElement;

    public bool RequiresTransaction => false;

    public Task<ToolResult> ExecuteAsync(JsonElement input, UIApplication app, CancellationToken ct)
    {
        var doc = app.ActiveUIDocument.Document;

        var collector = new FilteredElementCollector(doc)
            .OfClass(typeof(View))
            .Cast<View>()
            .Where(v => !v.IsTemplate); // Exclude view templates

        // Filter by type if specified
        if (input.TryGetProperty("view_type", out var viewTypeProp))
        {
            var viewTypeStr = viewTypeProp.GetString();
            var viewType = ParseViewType(viewTypeStr);
            collector = collector.Where(v => v.ViewType == viewType);
        }

        var views = collector.Select(v => new
        {
            id = v.Id.Value,
            name = v.Name,
            view_type = v.ViewType.ToString(),
            level = v.GenLevel?.Name,
            scale = v.Scale,
            is_active = v.Id == app.ActiveUIDocument.ActiveView.Id
        }).ToList();

        return Task.FromResult(ToolResult.Success(new
        {
            views,
            count = views.Count
        }));
    }

    private ViewType ParseViewType(string typeStr) => typeStr switch
    {
        "FloorPlan" => ViewType.FloorPlan,
        "CeilingPlan" => ViewType.CeilingPlan,
        "Elevation" => ViewType.Elevation,
        "Section" => ViewType.Section,
        "3D" or "ThreeD" => ViewType.ThreeD,
        "Schedule" => ViewType.Schedule,
        "Sheet" => ViewType.DrawingSheet,
        "Drafting" => ViewType.DraftingView,
        "Legend" => ViewType.Legend,
        _ => throw new ArgumentException($"Unknown view type: {typeStr}")
    };
}
```

### switch_view

Switches to an existing view by ID.

```csharp
public class SwitchViewTool : IRevitTool
{
    public string Name => "switch_view";

    public string Description =>
        "Switches the active view to the specified view by ID. " +
        "Use get_view_list first to find available view IDs.";

    public JsonElement InputSchema => JsonDocument.Parse("""
        {
            "type": "object",
            "properties": {
                "view_id": {
                    "type": "integer",
                    "description": "The element ID of the view to switch to"
                }
            },
            "required": ["view_id"]
        }
        """).RootElement;

    public bool RequiresTransaction => false;

    public Task<ToolResult> ExecuteAsync(JsonElement input, UIApplication app, CancellationToken ct)
    {
        var viewId = new ElementId(input.GetProperty("view_id").GetInt64());
        var doc = app.ActiveUIDocument.Document;

        var view = doc.GetElement(viewId) as View;
        if (view == null)
            return Task.FromResult(ToolResult.Error($"View with ID {viewId.Value} not found"));

        if (view.IsTemplate)
            return Task.FromResult(ToolResult.Error("Cannot switch to a view template"));

        app.ActiveUIDocument.ActiveView = view;

        return Task.FromResult(ToolResult.Success(new
        {
            switched_to = view.Name,
            view_type = view.ViewType.ToString(),
            view_id = view.Id.Value
        }));
    }
}
```

### open_view

Opens a view by name (searches Project Browser).

```csharp
public class OpenViewTool : IRevitTool
{
    public string Name => "open_view";

    public string Description =>
        "Opens a view by name. Searches all views and opens the matching one. " +
        "Optionally filter by view type to avoid ambiguity.";

    public JsonElement InputSchema => JsonDocument.Parse("""
        {
            "type": "object",
            "properties": {
                "view_name": {
                    "type": "string",
                    "description": "Name of the view to open (partial match supported)"
                },
                "view_type": {
                    "type": "string",
                    "description": "View type filter to narrow search",
                    "enum": ["FloorPlan", "CeilingPlan", "Elevation", "Section", "3D", "Schedule", "Sheet", "Drafting", "Legend"]
                }
            },
            "required": ["view_name"]
        }
        """).RootElement;

    public bool RequiresTransaction => false;

    public Task<ToolResult> ExecuteAsync(JsonElement input, UIApplication app, CancellationToken ct)
    {
        var viewName = input.GetProperty("view_name").GetString();
        var doc = app.ActiveUIDocument.Document;

        var query = new FilteredElementCollector(doc)
            .OfClass(typeof(View))
            .Cast<View>()
            .Where(v => !v.IsTemplate);

        // Filter by type if specified
        if (input.TryGetProperty("view_type", out var viewTypeProp))
        {
            var viewType = ParseViewType(viewTypeProp.GetString());
            query = query.Where(v => v.ViewType == viewType);
        }

        // Find matching views (case-insensitive, partial match)
        var matches = query
            .Where(v => v.Name.Contains(viewName, StringComparison.OrdinalIgnoreCase))
            .ToList();

        if (matches.Count == 0)
            return Task.FromResult(ToolResult.Error($"No view found matching '{viewName}'"));

        if (matches.Count > 1)
        {
            // Try exact match first
            var exactMatch = matches.FirstOrDefault(v =>
                v.Name.Equals(viewName, StringComparison.OrdinalIgnoreCase));

            if (exactMatch != null)
            {
                matches = new List<View> { exactMatch };
            }
            else
            {
                var names = string.Join(", ", matches.Take(10).Select(v => v.Name));
                return Task.FromResult(ToolResult.Error(
                    $"Multiple views match '{viewName}': {names}. Please be more specific or use view_type filter."));
            }
        }

        var view = matches[0];
        app.ActiveUIDocument.ActiveView = view;

        return Task.FromResult(ToolResult.Success(new
        {
            opened = view.Name,
            view_type = view.ViewType.ToString(),
            view_id = view.Id.Value
        }));
    }
}
```

### create_floor_plan_view

Creates a new floor plan view for a level.

```csharp
public class CreateFloorPlanViewTool : IRevitTool
{
    public string Name => "create_floor_plan_view";

    public string Description =>
        "Creates a new floor plan view for the specified level. " +
        "Optionally specify a view family type (use get_available_types with category 'ViewFamilyType' to list).";

    public JsonElement InputSchema => JsonDocument.Parse("""
        {
            "type": "object",
            "properties": {
                "level_id": {
                    "type": "integer",
                    "description": "The element ID of the level to create the plan for"
                },
                "name": {
                    "type": "string",
                    "description": "Name for the new view"
                },
                "view_family_type_id": {
                    "type": "integer",
                    "description": "Optional: specific ViewFamilyType ID to use"
                }
            },
            "required": ["level_id", "name"]
        }
        """).RootElement;

    public bool RequiresTransaction => true;

    public Task<ToolResult> ExecuteAsync(JsonElement input, UIApplication app, CancellationToken ct)
    {
        var doc = app.ActiveUIDocument.Document;
        var levelId = new ElementId(input.GetProperty("level_id").GetInt64());
        var name = input.GetProperty("name").GetString();

        var level = doc.GetElement(levelId) as Level;
        if (level == null)
            return Task.FromResult(ToolResult.Error($"Level with ID {levelId.Value} not found"));

        // Get ViewFamilyType for floor plans
        ViewFamilyType vft;
        if (input.TryGetProperty("view_family_type_id", out var vftIdProp))
        {
            vft = doc.GetElement(new ElementId(vftIdProp.GetInt64())) as ViewFamilyType;
            if (vft == null)
                return Task.FromResult(ToolResult.Error("Invalid view family type ID"));
        }
        else
        {
            vft = new FilteredElementCollector(doc)
                .OfClass(typeof(ViewFamilyType))
                .Cast<ViewFamilyType>()
                .FirstOrDefault(v => v.ViewFamily == ViewFamily.FloorPlan);
        }

        if (vft == null)
            return Task.FromResult(ToolResult.Error("No floor plan view family type found"));

        var view = ViewPlan.Create(doc, vft.Id, levelId);
        view.Name = name;

        return Task.FromResult(ToolResult.Success(new
        {
            created_view_id = view.Id.Value,
            name = view.Name,
            level = level.Name,
            view_type = "FloorPlan"
        }));
    }
}
```

### create_3d_view

Creates a new 3D view with optional preset orientation.

```csharp
public class Create3DViewTool : IRevitTool
{
    public string Name => "create_3d_view";

    public string Description =>
        "Creates a new 3D view. Optionally specify an orientation preset: " +
        "Isometric (default), Front, Back, Left, Right, Top, Bottom.";

    public JsonElement InputSchema => JsonDocument.Parse("""
        {
            "type": "object",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name for the new 3D view"
                },
                "orientation": {
                    "type": "string",
                    "description": "View orientation preset",
                    "enum": ["Isometric", "Front", "Back", "Left", "Right", "Top", "Bottom"],
                    "default": "Isometric"
                }
            },
            "required": ["name"]
        }
        """).RootElement;

    public bool RequiresTransaction => true;

    public Task<ToolResult> ExecuteAsync(JsonElement input, UIApplication app, CancellationToken ct)
    {
        var doc = app.ActiveUIDocument.Document;
        var name = input.GetProperty("name").GetString();
        var orientation = "Isometric";
        if (input.TryGetProperty("orientation", out var orientProp))
            orientation = orientProp.GetString();

        // Get 3D view family type
        var vft = new FilteredElementCollector(doc)
            .OfClass(typeof(ViewFamilyType))
            .Cast<ViewFamilyType>()
            .FirstOrDefault(v => v.ViewFamily == ViewFamily.ThreeDimensional);

        if (vft == null)
            return Task.FromResult(ToolResult.Error("No 3D view family type found"));

        var view = View3D.CreateIsometric(doc, vft.Id);
        view.Name = name;

        // Apply orientation
        var viewOrientation = GetViewOrientation(orientation);
        if (viewOrientation != null)
            view.SetOrientation(viewOrientation);

        return Task.FromResult(ToolResult.Success(new
        {
            created_view_id = view.Id.Value,
            name = view.Name,
            orientation,
            view_type = "3D"
        }));
    }

    private ViewOrientation3D? GetViewOrientation(string preset)
    {
        // Standard orientations looking at origin from distance
        var eye = preset switch
        {
            "Front" => new XYZ(0, -100, 0),
            "Back" => new XYZ(0, 100, 0),
            "Left" => new XYZ(-100, 0, 0),
            "Right" => new XYZ(100, 0, 0),
            "Top" => new XYZ(0, 0, 100),
            "Bottom" => new XYZ(0, 0, -100),
            "Isometric" => new XYZ(100, -100, 100),
            _ => null
        };

        if (eye == null) return null;

        var up = preset is "Top" or "Bottom" ? XYZ.BasisY : XYZ.BasisZ;
        var forward = (-eye).Normalize();

        return new ViewOrientation3D(eye, up, forward);
    }
}
```

### create_section_view

Creates a section view at a specified location and direction.

```csharp
public class CreateSectionViewTool : IRevitTool
{
    public string Name => "create_section_view";

    public string Description =>
        "Creates a section view at the specified origin point, looking in the specified direction. " +
        "The section plane is perpendicular to the direction vector.";

    public JsonElement InputSchema => JsonDocument.Parse("""
        {
            "type": "object",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name for the new section view"
                },
                "origin": {
                    "type": "object",
                    "description": "Origin point of the section (in feet)",
                    "properties": {
                        "x": { "type": "number" },
                        "y": { "type": "number" },
                        "z": { "type": "number" }
                    },
                    "required": ["x", "y", "z"]
                },
                "direction": {
                    "type": "object",
                    "description": "View direction vector (section looks this direction)",
                    "properties": {
                        "x": { "type": "number" },
                        "y": { "type": "number" },
                        "z": { "type": "number" }
                    },
                    "required": ["x", "y", "z"]
                },
                "width": {
                    "type": "number",
                    "description": "Section width in feet (default 20)",
                    "default": 20
                },
                "height": {
                    "type": "number",
                    "description": "Section height in feet (default 20)",
                    "default": 20
                },
                "depth": {
                    "type": "number",
                    "description": "Section depth/far clip in feet (default 10)",
                    "default": 10
                }
            },
            "required": ["name", "origin", "direction"]
        }
        """).RootElement;

    public bool RequiresTransaction => true;

    public Task<ToolResult> ExecuteAsync(JsonElement input, UIApplication app, CancellationToken ct)
    {
        var doc = app.ActiveUIDocument.Document;
        var name = input.GetProperty("name").GetString();

        var originProp = input.GetProperty("origin");
        var origin = new XYZ(
            originProp.GetProperty("x").GetDouble(),
            originProp.GetProperty("y").GetDouble(),
            originProp.GetProperty("z").GetDouble());

        var dirProp = input.GetProperty("direction");
        var direction = new XYZ(
            dirProp.GetProperty("x").GetDouble(),
            dirProp.GetProperty("y").GetDouble(),
            dirProp.GetProperty("z").GetDouble()).Normalize();

        var width = input.TryGetProperty("width", out var w) ? w.GetDouble() : 20.0;
        var height = input.TryGetProperty("height", out var h) ? h.GetDouble() : 20.0;
        var depth = input.TryGetProperty("depth", out var d) ? d.GetDouble() : 10.0;

        // Get section view family type
        var vft = new FilteredElementCollector(doc)
            .OfClass(typeof(ViewFamilyType))
            .Cast<ViewFamilyType>()
            .FirstOrDefault(v => v.ViewFamily == ViewFamily.Section);

        if (vft == null)
            return Task.FromResult(ToolResult.Error("No section view family type found"));

        // Create section box transform
        var right = direction.CrossProduct(XYZ.BasisZ).Normalize();
        if (right.IsZeroLength())
            right = XYZ.BasisX;
        var up = right.CrossProduct(direction);

        var transform = Transform.Identity;
        transform.Origin = origin;
        transform.BasisX = right;
        transform.BasisY = up;
        transform.BasisZ = direction;

        // Section box bounds (relative to transform)
        var sectionBox = new BoundingBoxXYZ
        {
            Transform = transform,
            Min = new XYZ(-width / 2, -height / 2, 0),
            Max = new XYZ(width / 2, height / 2, depth)
        };

        var view = ViewSection.CreateSection(doc, vft.Id, sectionBox);
        view.Name = name;

        return Task.FromResult(ToolResult.Success(new
        {
            created_view_id = view.Id.Value,
            name = view.Name,
            view_type = "Section"
        }));
    }
}
```

### create_schedule_view

Creates a schedule for a specified category.

```csharp
public class CreateScheduleViewTool : IRevitTool
{
    public string Name => "create_schedule_view";

    public string Description =>
        "Creates a schedule view for the specified category with the specified fields. " +
        "Use get_available_types to see schedulable categories.";

    public JsonElement InputSchema => JsonDocument.Parse("""
        {
            "type": "object",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name for the schedule"
                },
                "category": {
                    "type": "string",
                    "description": "Category to schedule (e.g., Walls, Doors, Structural Columns)"
                },
                "fields": {
                    "type": "array",
                    "items": { "type": "string" },
                    "description": "Parameter names to include as columns"
                }
            },
            "required": ["name", "category", "fields"]
        }
        """).RootElement;

    public bool RequiresTransaction => true;

    public Task<ToolResult> ExecuteAsync(JsonElement input, UIApplication app, CancellationToken ct)
    {
        var doc = app.ActiveUIDocument.Document;
        var name = input.GetProperty("name").GetString();
        var categoryStr = input.GetProperty("category").GetString();
        var fields = input.GetProperty("fields").EnumerateArray()
            .Select(f => f.GetString()).ToList();

        if (!CategoryHelper.TryGetCategory(categoryStr, out var builtInCategory))
            return Task.FromResult(ToolResult.Error(CategoryHelper.GetInvalidCategoryError(categoryStr)));

        var category = Category.GetCategory(doc, builtInCategory);
        if (category == null)
            return Task.FromResult(ToolResult.Error($"Category {categoryStr} not found in document"));

        var schedule = ViewSchedule.CreateSchedule(doc, category.Id);
        schedule.Name = name;

        // Add fields
        var definition = schedule.Definition;
        var addedFields = new List<string>();
        var failedFields = new List<string>();

        foreach (var fieldName in fields)
        {
            var schedulableField = definition.GetSchedulableFields()
                .FirstOrDefault(f => f.GetName(doc).Equals(fieldName, StringComparison.OrdinalIgnoreCase));

            if (schedulableField != null)
            {
                definition.AddField(schedulableField);
                addedFields.Add(fieldName);
            }
            else
            {
                failedFields.Add(fieldName);
            }
        }

        return Task.FromResult(ToolResult.Success(new
        {
            created_view_id = schedule.Id.Value,
            name = schedule.Name,
            category = categoryStr,
            added_fields = addedFields,
            failed_fields = failedFields.Count > 0 ? failedFields : null,
            view_type = "Schedule"
        }));
    }
}
```

### create_drafting_view

Creates a blank drafting view.

```csharp
public class CreateDraftingViewTool : IRevitTool
{
    public string Name => "create_drafting_view";

    public string Description =>
        "Creates a new drafting view (2D detail view not associated with model geometry).";

    public JsonElement InputSchema => JsonDocument.Parse("""
        {
            "type": "object",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name for the drafting view"
                },
                "scale": {
                    "type": "integer",
                    "description": "View scale (e.g., 48 for 1/4\" = 1'-0\", 96 for 1/8\" = 1'-0\")",
                    "default": 48
                }
            },
            "required": ["name"]
        }
        """).RootElement;

    public bool RequiresTransaction => true;

    public Task<ToolResult> ExecuteAsync(JsonElement input, UIApplication app, CancellationToken ct)
    {
        var doc = app.ActiveUIDocument.Document;
        var name = input.GetProperty("name").GetString();
        var scale = input.TryGetProperty("scale", out var s) ? s.GetInt32() : 48;

        var vft = new FilteredElementCollector(doc)
            .OfClass(typeof(ViewFamilyType))
            .Cast<ViewFamilyType>()
            .FirstOrDefault(v => v.ViewFamily == ViewFamily.Drafting);

        if (vft == null)
            return Task.FromResult(ToolResult.Error("No drafting view family type found"));

        var view = ViewDrafting.Create(doc, vft.Id);
        view.Name = name;
        view.Scale = scale;

        return Task.FromResult(ToolResult.Success(new
        {
            created_view_id = view.Id.Value,
            name = view.Name,
            scale,
            view_type = "Drafting"
        }));
    }
}
```

---

## Verification Checklist

- [x] `get_view_list` returns all views, respects type filter
- [x] `switch_view` changes active view by ID
- [x] `open_view` finds and opens view by name with partial matching
- [x] `create_floor_plan_view` creates plan for specified level
- [x] `create_ceiling_plan_view` creates ceiling plan for specified level
- [x] `create_3d_view` creates 3D view with orientation presets
- [x] `create_section_view` creates section at specified location/direction
- [x] `create_elevation_view` creates elevation at location using ElevationMarker
- [x] `create_schedule_view` creates schedule with specified fields
- [x] `create_drafting_view` creates blank drafting view
- [x] `duplicate_view` clones view with duplicate options
- [x] `rename_view` changes view name
- [x] `delete_view` shows confirmation, then deletes
- [x] `get_available_types` with "ViewFamilyType" returns grouped types
- [x] All view creation tools integrate with undo (single Ctrl+Z)
- [x] Error messages include helpful suggestions

---

## Future Enhancements (Deferred)

| Enhancement | Target Phase | Notes |
|-------------|--------------|-------|
| `set_view_scale` | P2-08+ | Set `view.Scale` to control viewport size on sheets. Discovered during P2-08.4 — without this, placed viewports may be oversized. Simple API: `view.Scale = n` where n is denominator (e.g., 96 = 1/8" = 1'-0"). Also consider `set_crop_region` for fine control. |
| Create dependent views | P2-01 | Cropped views dependent on parent |
| Duplicate view with detailing | P2-01 | Copy annotations to new view |
| Create legend view | P2-01 | Legend creation is more complex |
| Create callout view | P2-01 | Callouts from parent views |
