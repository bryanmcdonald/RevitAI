# P1.5-03: Camera Control

**Status**: Complete

**Goal**: Enable Claude to control the camera in Revit views - zoom, pan, orbit, and set view orientations - to focus on relevant parts of the model.

**Prerequisites**: P1.5-02 complete.

---

## Files Created

```
src/RevitAI/Tools/ViewTools/
├── ZoomToFitTool.cs            # zoom_to_fit
├── ZoomToElementsTool.cs       # zoom_to_elements
├── ZoomToBoundsTool.cs         # zoom_to_bounds
├── ZoomByPercentTool.cs        # zoom_by_percent
├── PanViewTool.cs              # pan_view
├── OrbitViewTool.cs            # orbit_view (3D only)
└── SetViewOrientationTool.cs   # set_view_orientation (3D only)

src/RevitAI/Helpers/
└── ViewOrientationHelper.cs    # Preset orientations and math utilities
```

**Modified**: `src/RevitAI/App.cs` - Register all tools

---

## Tool Summary

| Tool Name | Input | Output | 2D | 3D | Transaction |
|-----------|-------|--------|----|----|-------------|
| `zoom_to_fit` | - | Success | Yes | Yes | No |
| `zoom_to_elements` | `element_ids: int[]` | Success | Yes | Yes | No |
| `zoom_to_bounds` | `min_x, min_y, max_x, max_y` | Success | Yes | Yes | No |
| `zoom_by_percent` | `percent: number` | Success | Yes | Yes | No |
| `pan_view` | `direction` or `center_on_element_id` or `center_on_point` | Success | Yes | Yes | No |
| `orbit_view` | `horizontal_degrees`, `vertical_degrees` | Success | No | Yes | No |
| `set_view_orientation` | `orientation: string` | Success | No | Yes | No |

---

## Implementation Details

### UIView Access

Most camera operations use `UIView` which represents the viewport in the UI:

```csharp
private UIView GetActiveUIView(UIDocument uiDoc)
{
    var uiViews = uiDoc.GetOpenUIViews();
    return uiViews.FirstOrDefault(v => v.ViewId == uiDoc.ActiveView.Id);
}
```

### zoom_to_fit

Zooms to show the entire model extents.

```csharp
public class ZoomToFitTool : IRevitTool
{
    public string Name => "zoom_to_fit";

    public string Description =>
        "Zooms the current view to fit all visible elements. " +
        "Useful to get an overview of the model or reset the view.";

    public JsonElement InputSchema => JsonDocument.Parse("""
        {
            "type": "object",
            "properties": {}
        }
        """).RootElement;

    public bool RequiresTransaction => false;

    public Task<ToolResult> ExecuteAsync(JsonElement input, UIApplication app, CancellationToken ct)
    {
        var uiDoc = app.ActiveUIDocument;
        var uiView = GetActiveUIView(uiDoc);

        if (uiView == null)
            return Task.FromResult(ToolResult.Error("No active view found"));

        uiView.ZoomToFit();

        return Task.FromResult(ToolResult.Success(new
        {
            action = "zoom_to_fit",
            view_name = uiDoc.ActiveView.Name
        }));
    }
}
```

### zoom_to_elements

Zooms to fit specified elements in view.

```csharp
public class ZoomToElementsTool : IRevitTool
{
    public string Name => "zoom_to_elements";

    public string Description =>
        "Zooms the view to focus on the specified elements. " +
        "Useful to inspect specific elements or verify placement.";

    public JsonElement InputSchema => JsonDocument.Parse("""
        {
            "type": "object",
            "properties": {
                "element_ids": {
                    "type": "array",
                    "items": { "type": "integer" },
                    "description": "Element IDs to zoom to"
                },
                "factor": {
                    "type": "number",
                    "description": "Zoom factor (1.0 = fit exactly, 1.2 = 20% padding). Default 1.2",
                    "default": 1.2
                }
            },
            "required": ["element_ids"]
        }
        """).RootElement;

    public bool RequiresTransaction => false;

    public Task<ToolResult> ExecuteAsync(JsonElement input, UIApplication app, CancellationToken ct)
    {
        var uiDoc = app.ActiveUIDocument;
        var doc = uiDoc.Document;
        var uiView = GetActiveUIView(uiDoc);

        if (uiView == null)
            return Task.FromResult(ToolResult.Error("No active view found"));

        var elementIds = input.GetProperty("element_ids").EnumerateArray()
            .Select(e => new ElementId(e.GetInt64())).ToList();

        var factor = input.TryGetProperty("factor", out var f) ? f.GetDouble() : 1.2;

        // Calculate bounding box encompassing all elements
        BoundingBoxXYZ combinedBox = null;
        var validElements = 0;

        foreach (var id in elementIds)
        {
            var element = doc.GetElement(id);
            if (element == null) continue;

            var box = element.get_BoundingBox(uiDoc.ActiveView);
            if (box == null) continue;

            validElements++;
            if (combinedBox == null)
            {
                combinedBox = new BoundingBoxXYZ
                {
                    Min = box.Min,
                    Max = box.Max
                };
            }
            else
            {
                combinedBox.Min = new XYZ(
                    Math.Min(combinedBox.Min.X, box.Min.X),
                    Math.Min(combinedBox.Min.Y, box.Min.Y),
                    Math.Min(combinedBox.Min.Z, box.Min.Z));
                combinedBox.Max = new XYZ(
                    Math.Max(combinedBox.Max.X, box.Max.X),
                    Math.Max(combinedBox.Max.Y, box.Max.Y),
                    Math.Max(combinedBox.Max.Z, box.Max.Z));
            }
        }

        if (combinedBox == null)
            return Task.FromResult(ToolResult.Error("No valid elements with geometry found"));

        // Apply zoom factor (expand bounds)
        var center = (combinedBox.Min + combinedBox.Max) / 2;
        var halfSize = (combinedBox.Max - combinedBox.Min) / 2 * factor;

        var corners = new UIView.GetZoomCorners(
            new XYZ(center.X - halfSize.X, center.Y - halfSize.Y, center.Z - halfSize.Z),
            new XYZ(center.X + halfSize.X, center.Y + halfSize.Y, center.Z + halfSize.Z));

        uiView.ZoomAndCenterRectangle(corners.Corner1, corners.Corner2);

        return Task.FromResult(ToolResult.Success(new
        {
            action = "zoom_to_elements",
            element_count = validElements,
            total_requested = elementIds.Count
        }));
    }
}
```

### zoom_to_bounds

Zooms to a specific coordinate bounding box.

```csharp
public class ZoomToBoundsTool : IRevitTool
{
    public string Name => "zoom_to_bounds";

    public string Description =>
        "Zooms the view to show a specific rectangular area. " +
        "Coordinates are in feet (Revit internal units).";

    public JsonElement InputSchema => JsonDocument.Parse("""
        {
            "type": "object",
            "properties": {
                "min_x": { "type": "number", "description": "Minimum X coordinate (feet)" },
                "min_y": { "type": "number", "description": "Minimum Y coordinate (feet)" },
                "max_x": { "type": "number", "description": "Maximum X coordinate (feet)" },
                "max_y": { "type": "number", "description": "Maximum Y coordinate (feet)" },
                "min_z": { "type": "number", "description": "Minimum Z (for 3D views, feet)" },
                "max_z": { "type": "number", "description": "Maximum Z (for 3D views, feet)" }
            },
            "required": ["min_x", "min_y", "max_x", "max_y"]
        }
        """).RootElement;

    public bool RequiresTransaction => false;

    public Task<ToolResult> ExecuteAsync(JsonElement input, UIApplication app, CancellationToken ct)
    {
        var uiDoc = app.ActiveUIDocument;
        var uiView = GetActiveUIView(uiDoc);

        if (uiView == null)
            return Task.FromResult(ToolResult.Error("No active view found"));

        var minX = input.GetProperty("min_x").GetDouble();
        var minY = input.GetProperty("min_y").GetDouble();
        var maxX = input.GetProperty("max_x").GetDouble();
        var maxY = input.GetProperty("max_y").GetDouble();
        var minZ = input.TryGetProperty("min_z", out var minZp) ? minZp.GetDouble() : 0;
        var maxZ = input.TryGetProperty("max_z", out var maxZp) ? maxZp.GetDouble() : 0;

        var corner1 = new XYZ(minX, minY, minZ);
        var corner2 = new XYZ(maxX, maxY, maxZ);

        uiView.ZoomAndCenterRectangle(corner1, corner2);

        return Task.FromResult(ToolResult.Success(new
        {
            action = "zoom_to_bounds",
            bounds = new { min_x = minX, min_y = minY, max_x = maxX, max_y = maxY }
        }));
    }
}
```

### zoom_by_percent

Zooms in or out by a percentage.

```csharp
public class ZoomByPercentTool : IRevitTool
{
    public string Name => "zoom_by_percent";

    public string Description =>
        "Zooms in or out by a percentage. Values > 100 zoom in (200 = 2x closer), " +
        "values < 100 zoom out (50 = 2x farther). Centered on current view center.";

    public JsonElement InputSchema => JsonDocument.Parse("""
        {
            "type": "object",
            "properties": {
                "percent": {
                    "type": "number",
                    "description": "Zoom percentage (200 = 2x zoom in, 50 = 2x zoom out)"
                }
            },
            "required": ["percent"]
        }
        """).RootElement;

    public bool RequiresTransaction => false;

    public Task<ToolResult> ExecuteAsync(JsonElement input, UIApplication app, CancellationToken ct)
    {
        var uiDoc = app.ActiveUIDocument;
        var uiView = GetActiveUIView(uiDoc);

        if (uiView == null)
            return Task.FromResult(ToolResult.Error("No active view found"));

        var percent = input.GetProperty("percent").GetDouble();
        if (percent <= 0)
            return Task.FromResult(ToolResult.Error("Percent must be greater than 0"));

        // Get current zoom corners
        var zoomCorners = uiView.GetZoomCorners();
        var corner1 = zoomCorners.Item1;
        var corner2 = zoomCorners.Item2;

        // Calculate center and current size
        var center = (corner1 + corner2) / 2;
        var halfSize = (corner2 - corner1) / 2;

        // Scale by inverse of percent (zoom in = smaller region)
        var scaleFactor = 100.0 / percent;
        var newHalfSize = halfSize * scaleFactor;

        var newCorner1 = center - newHalfSize;
        var newCorner2 = center + newHalfSize;

        uiView.ZoomAndCenterRectangle(newCorner1, newCorner2);

        return Task.FromResult(ToolResult.Success(new
        {
            action = "zoom_by_percent",
            percent,
            direction = percent > 100 ? "in" : "out"
        }));
    }
}
```

### pan_view

Pans the view by direction, to center on an element, or to center on a point.

```csharp
public class PanViewTool : IRevitTool
{
    public string Name => "pan_view";

    public string Description =>
        "Pans the view. Specify either: direction (north/south/east/west + distance), " +
        "center_on_element_id (pan to center on element), or center_on_point (pan to coordinates).";

    public JsonElement InputSchema => JsonDocument.Parse("""
        {
            "type": "object",
            "properties": {
                "direction": {
                    "type": "string",
                    "description": "Pan direction: north, south, east, west, or cardinal + distance (e.g., 'north 10')",
                    "enum": ["north", "south", "east", "west"]
                },
                "distance": {
                    "type": "number",
                    "description": "Pan distance in feet (used with direction)",
                    "default": 10
                },
                "center_on_element_id": {
                    "type": "integer",
                    "description": "Element ID to center the view on"
                },
                "center_on_point": {
                    "type": "object",
                    "description": "Point to center the view on (in feet)",
                    "properties": {
                        "x": { "type": "number" },
                        "y": { "type": "number" },
                        "z": { "type": "number" }
                    },
                    "required": ["x", "y"]
                }
            }
        }
        """).RootElement;

    public bool RequiresTransaction => false;

    public Task<ToolResult> ExecuteAsync(JsonElement input, UIApplication app, CancellationToken ct)
    {
        var uiDoc = app.ActiveUIDocument;
        var doc = uiDoc.Document;
        var uiView = GetActiveUIView(uiDoc);

        if (uiView == null)
            return Task.FromResult(ToolResult.Error("No active view found"));

        var zoomCorners = uiView.GetZoomCorners();
        var corner1 = zoomCorners.Item1;
        var corner2 = zoomCorners.Item2;
        var currentCenter = (corner1 + corner2) / 2;
        var halfSize = (corner2 - corner1) / 2;

        XYZ newCenter;
        string action;

        if (input.TryGetProperty("center_on_element_id", out var elemIdProp))
        {
            var elementId = new ElementId(elemIdProp.GetInt64());
            var element = doc.GetElement(elementId);
            if (element == null)
                return Task.FromResult(ToolResult.Error($"Element {elementId.Value} not found"));

            var box = element.get_BoundingBox(uiDoc.ActiveView);
            if (box == null)
                return Task.FromResult(ToolResult.Error("Element has no geometry in current view"));

            newCenter = (box.Min + box.Max) / 2;
            action = $"center_on_element_{elementId.Value}";
        }
        else if (input.TryGetProperty("center_on_point", out var pointProp))
        {
            newCenter = new XYZ(
                pointProp.GetProperty("x").GetDouble(),
                pointProp.GetProperty("y").GetDouble(),
                pointProp.TryGetProperty("z", out var z) ? z.GetDouble() : currentCenter.Z);
            action = "center_on_point";
        }
        else if (input.TryGetProperty("direction", out var dirProp))
        {
            var direction = dirProp.GetString().ToLower();
            var distance = input.TryGetProperty("distance", out var d) ? d.GetDouble() : 10.0;

            var offset = direction switch
            {
                "north" => new XYZ(0, distance, 0),
                "south" => new XYZ(0, -distance, 0),
                "east" => new XYZ(distance, 0, 0),
                "west" => new XYZ(-distance, 0, 0),
                _ => XYZ.Zero
            };

            if (offset.IsZeroLength())
                return Task.FromResult(ToolResult.Error($"Invalid direction: {direction}"));

            newCenter = currentCenter + offset;
            action = $"pan_{direction}_{distance}ft";
        }
        else
        {
            return Task.FromResult(ToolResult.Error(
                "Specify one of: direction, center_on_element_id, or center_on_point"));
        }

        var newCorner1 = newCenter - halfSize;
        var newCorner2 = newCenter + halfSize;

        uiView.ZoomAndCenterRectangle(newCorner1, newCorner2);

        return Task.FromResult(ToolResult.Success(new
        {
            action,
            new_center = new { x = newCenter.X, y = newCenter.Y, z = newCenter.Z }
        }));
    }
}
```

### orbit_view

Orbits a 3D view by horizontal and vertical angles.

```csharp
public class OrbitViewTool : IRevitTool
{
    public string Name => "orbit_view";

    public string Description =>
        "Orbits a 3D view by rotating the camera around the model. " +
        "Positive horizontal rotates clockwise (from above), positive vertical tilts up. " +
        "Only works in 3D views.";

    public JsonElement InputSchema => JsonDocument.Parse("""
        {
            "type": "object",
            "properties": {
                "horizontal_degrees": {
                    "type": "number",
                    "description": "Horizontal rotation in degrees (positive = clockwise from above)",
                    "default": 0
                },
                "vertical_degrees": {
                    "type": "number",
                    "description": "Vertical rotation in degrees (positive = tilt up)",
                    "default": 0
                }
            }
        }
        """).RootElement;

    public bool RequiresTransaction => false;

    public Task<ToolResult> ExecuteAsync(JsonElement input, UIApplication app, CancellationToken ct)
    {
        var uiDoc = app.ActiveUIDocument;
        var view = uiDoc.ActiveView as View3D;

        if (view == null)
            return Task.FromResult(ToolResult.Error("orbit_view only works in 3D views"));

        if (view.IsLocked)
            return Task.FromResult(ToolResult.Error("Cannot orbit a locked 3D view"));

        var horizontalDeg = input.TryGetProperty("horizontal_degrees", out var h) ? h.GetDouble() : 0;
        var verticalDeg = input.TryGetProperty("vertical_degrees", out var v) ? v.GetDouble() : 0;

        if (horizontalDeg == 0 && verticalDeg == 0)
            return Task.FromResult(ToolResult.Error("Specify horizontal_degrees and/or vertical_degrees"));

        var currentOrientation = view.GetOrientation();
        var eyePosition = currentOrientation.EyePosition;
        var forwardDirection = currentOrientation.ForwardDirection;
        var upDirection = currentOrientation.UpDirection;

        // Calculate target point (what we're looking at)
        var targetDistance = 100.0; // Approximate
        var target = eyePosition + forwardDirection * targetDistance;

        // Rotate around vertical axis (horizontal orbit)
        if (horizontalDeg != 0)
        {
            var horizontalRad = horizontalDeg * Math.PI / 180.0;
            var rotationAxis = XYZ.BasisZ; // World up
            var rotation = Transform.CreateRotation(rotationAxis, horizontalRad);

            var eyeToTarget = target - eyePosition;
            var newEyeToTarget = rotation.OfVector(eyeToTarget);
            eyePosition = target - newEyeToTarget;
            forwardDirection = rotation.OfVector(forwardDirection);
            upDirection = rotation.OfVector(upDirection);
        }

        // Rotate around horizontal axis (vertical orbit)
        if (verticalDeg != 0)
        {
            var verticalRad = verticalDeg * Math.PI / 180.0;
            var rightDirection = forwardDirection.CrossProduct(upDirection);
            var rotation = Transform.CreateRotation(rightDirection, -verticalRad);

            var eyeToTarget = target - eyePosition;
            var newEyeToTarget = rotation.OfVector(eyeToTarget);
            eyePosition = target - newEyeToTarget;
            forwardDirection = rotation.OfVector(forwardDirection);
            upDirection = rotation.OfVector(upDirection);
        }

        var newOrientation = new ViewOrientation3D(eyePosition, upDirection, forwardDirection);
        view.SetOrientation(newOrientation);

        return Task.FromResult(ToolResult.Success(new
        {
            action = "orbit",
            horizontal_degrees = horizontalDeg,
            vertical_degrees = verticalDeg
        }));
    }
}
```

### set_view_orientation

Sets a 3D view to a preset orientation.

```csharp
public class SetViewOrientationTool : IRevitTool
{
    public string Name => "set_view_orientation";

    public string Description =>
        "Sets a 3D view to a preset orientation. Only works in 3D views.";

    public JsonElement InputSchema => JsonDocument.Parse("""
        {
            "type": "object",
            "properties": {
                "orientation": {
                    "type": "string",
                    "description": "Preset orientation",
                    "enum": ["Isometric", "IsometricNE", "IsometricNW", "IsometricSE", "IsometricSW",
                             "Front", "Back", "Left", "Right", "Top", "Bottom"]
                }
            },
            "required": ["orientation"]
        }
        """).RootElement;

    public bool RequiresTransaction => false;

    public Task<ToolResult> ExecuteAsync(JsonElement input, UIApplication app, CancellationToken ct)
    {
        var uiDoc = app.ActiveUIDocument;
        var view = uiDoc.ActiveView as View3D;

        if (view == null)
            return Task.FromResult(ToolResult.Error("set_view_orientation only works in 3D views"));

        if (view.IsLocked)
            return Task.FromResult(ToolResult.Error("Cannot change orientation of a locked 3D view"));

        var orientationStr = input.GetProperty("orientation").GetString();
        var orientation = ViewOrientationHelper.GetPresetOrientation(orientationStr);

        if (orientation == null)
            return Task.FromResult(ToolResult.Error($"Unknown orientation: {orientationStr}"));

        view.SetOrientation(orientation);

        // Also zoom to fit after orientation change
        var uiView = GetActiveUIView(uiDoc);
        uiView?.ZoomToFit();

        return Task.FromResult(ToolResult.Success(new
        {
            action = "set_orientation",
            orientation = orientationStr
        }));
    }
}
```

### ViewOrientationHelper

```csharp
public static class ViewOrientationHelper
{
    public static ViewOrientation3D GetPresetOrientation(string preset)
    {
        // Distance from origin for eye position
        const double distance = 100.0;

        // Calculate eye position, up vector, and forward direction
        var (eye, up) = preset switch
        {
            "Front" => (new XYZ(0, -distance, 0), XYZ.BasisZ),
            "Back" => (new XYZ(0, distance, 0), XYZ.BasisZ),
            "Left" => (new XYZ(-distance, 0, 0), XYZ.BasisZ),
            "Right" => (new XYZ(distance, 0, 0), XYZ.BasisZ),
            "Top" => (new XYZ(0, 0, distance), XYZ.BasisY),
            "Bottom" => (new XYZ(0, 0, -distance), -XYZ.BasisY),
            "Isometric" or "IsometricSE" => (new XYZ(distance, -distance, distance), XYZ.BasisZ),
            "IsometricNE" => (new XYZ(distance, distance, distance), XYZ.BasisZ),
            "IsometricNW" => (new XYZ(-distance, distance, distance), XYZ.BasisZ),
            "IsometricSW" => (new XYZ(-distance, -distance, distance), XYZ.BasisZ),
            _ => (null, null)
        };

        if (eye == null) return null;

        var forward = (-eye).Normalize();
        return new ViewOrientation3D(eye, up, forward);
    }
}
```

---

## Lessons Learned (Implementation Notes)

### Orbit Center Calculation - Critical for Proper Orbiting

The most challenging aspect of `orbit_view` was determining **what point to orbit around**. Early implementations orbited around arbitrary points in space, causing the model to fly out of view.

**Failed approaches:**
1. **Fixed distance from camera** (e.g., 100ft forward) - Doesn't relate to actual model position
2. **`WhereElementIsViewIndependent()` collector** - Returned elements but bounding boxes weren't reliable
3. **Ray casting alone** - `ReferenceIntersector` often missed geometry

**Working solution - Priority-based target selection:**
```csharp
// Priority order for orbit center:
// 1. Selected elements - orbit around selection center
// 2. Ray cast hit (Navisworks-style) - element at screen center
// 3. Section box center - if active
// 4. Visible model center - calculated from view-visible elements
// 5. Fallback - 100ft forward (last resort)
```

**Key insight: Use `FilteredElementCollector(doc, view3d.Id)`** instead of `FilteredElementCollector(doc)` to get elements visible in the current view. Also exclude site/topography categories which have huge extents:
```csharp
var collector = new FilteredElementCollector(doc, view3d.Id)
    .WhereElementIsNotElementType();

// Skip: OST_Topography, OST_Site, OST_Planting, OST_Entourage, OST_Cameras
```

### View Refresh After SetOrientation

After calling `view3d.SetOrientation(newOrientation)`, the view doesn't automatically refresh. Solutions:
- **OrbitViewTool**: Re-apply zoom corners: `uiView.ZoomAndCenterRectangle(corners[0], corners[1])`
- **SetViewOrientationTool**: Call `uiView.ZoomToFit()` since orientation change warrants re-framing

### Isometric View Up Direction

The up direction must be **orthogonal to the forward direction**. For isometric views where forward points downward, world Z isn't perpendicular. Calculate proper up:
```csharp
var worldUp = XYZ.BasisZ;
var rightDirection = forwardDirection.CrossProduct(worldUp).Normalize();
var upDirection = rightDirection.CrossProduct(forwardDirection).Normalize();
```

### Rotation Math - Always Recalculate Forward

After rotating the eye position around a target, **recalculate forward direction** to point at target:
```csharp
var newEyePosition = rotation.OfPoint(orientation.EyePosition);
var newForward = (target - newEyePosition).Normalize(); // Don't just rotate old forward!
```

---

## Verification Checklist

- [x] `zoom_to_fit` shows entire model in view
- [x] `zoom_to_elements` centers and fits specified elements
- [x] `zoom_to_bounds` zooms to exact coordinate region
- [x] `zoom_by_percent` zooms in (>100) and out (<100) correctly
- [x] `pan_view` moves view by direction and distance
- [x] `pan_view` centers on specified element
- [x] `pan_view` centers on specified coordinates
- [x] `orbit_view` rotates 3D view horizontally and vertically
- [x] `orbit_view` orbits around selected elements when present
- [x] `orbit_view` orbits around visible model center when nothing selected
- [x] `orbit_view` errors gracefully on 2D views
- [x] `set_view_orientation` applies all preset orientations
- [x] `set_view_orientation` centers on selected elements or model
- [x] All tools work in floor plans, elevations, sections, and 3D views (where applicable)

---

## Future Enhancements (Deferred)

| Enhancement | Target Phase | Notes |
|-------------|--------------|-------|
| Animated transitions | P2-05 | Smooth zoom/pan animations |
| Save/restore camera positions | P2-07 | Named camera bookmarks |
| Zoom to selection | P2-04 | Zoom to current selection automatically |
| Walk-through mode | P3-04 | First-person navigation for presentations |
